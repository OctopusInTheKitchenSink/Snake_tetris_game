# BrickGame v2.0

Проект объединяет логику двух классических аркадных игр — ```Tetris``` и ```Snake``` — в единую модульную систему с поддержкой консольного и десктопного интерфейсов.
Реализовано на ```C++20``` с соблюдением принципов ```MVC```, конечного автомата.

## Содержание
- [Обзор проекта](#Обзор-проекта)
- [Архитектура](#Архитектура)
  - [Структура проекта](#Структура-проекта)
  - [Конечный автомат (Snake)](#Конечный-автомат-(Snake))
  - [Паттерн MVC](#Паттер-MVC)
- [Логика игр](#Логика-игр)
  - [Snake](#Snake)
  - [Tetris](#Tetris)
- [Интерфейсы](#Интерфейсы)
  - [Консольный интерфейс](#Консольный-интерфейс)
  - [Десктопный интерфейс (Qt)](#Десктопный-интерфейс-(Qt))
- [Сборка и установка](#Сборка-и-установка)
- [Тестирование](#Тестирование)
- [Хранение рекорда](#Хранение-рекорда)
- [Диаграмма конечного автомата](#Диаграмма-конечного-автомата)


## Обзор проекта
Проект ```BrickGame v2.0``` расширяет функциональность предыдущей версии (```Tetris```), добавляя:

- реализацию игры ```Snake``` с полной логикой и поддержкой уровней;
- единый ```API``` для двух игр через общую библиотеку;
- десктопный ```GUI``` на базе ```Qt``` с поддержкой обеих игр;
- сохранение рекорда между запусками;
- строгую архитектурную декомпозицию по принципу ```MVC``` и ```конечного автомата```.

## Архитектура
### Структура проекта

src/<br>
├── brick_game/<br>
│   ├── tetris/          # Логика Tetris (из v1.0)<br>
│   └── snake/           # Логика Snake (новая реализация)<br>
├── gui/<br>
│   ├── cli/             # Консольный интерфейс (из v1.0, адаптирован)<br>
│   └── desktop/         # Десктопный интерфейс на Qt<br>
tests/                   # Unit-тесты (GTest)<br>
materials/               # Спецификации, диаграммы<br>
Makefile<br>
README.md<br>

Все классы и функции логики размещены в пространстве имён s21.

### Конечный автомат (Snake)
Логика игры Snake управляется конечным автоматом (КА) со следующими состояниями:

Состояние|Описание
-|-
```START```|Начальное состояние. Игра инициализируется: создается змейка, генерируется первое яблоко. После этого происходит переход в состояние ```SRAWN```
```SPAWN```|Состояние "порождения" или подготовки к началу движения. Здесь могут выполняться финальные действия перед стартом (например, установка таймера). Переход в состояние ```MOVING```
```MOVING```|Основное состояние игрового цикла. Змейка движется по полю. В этом состоянии происходят все основные проверки: пользовательский ввод, коллизии, проверка на победу/поражение. Из этого состояния возможны переходы в ```PAUSE```, ```SHIFT``` (движение), ```USER_INPUT```, ```COLLISION_CHECK``` и обратно в MOVING после выполнения действий.
```PAUSE```|Игра приостановлена. Движение змейки останавливается. Ожидание команды пользователя (обычно нажатия клавиши ```P```) для возобновления. После возобновления — возврат в ```MOVING```
```USER_INPUT```|Обработка ввода от пользователя (нажатие стрелок). Проверяется, является ли введённое направление корректным (не противоположно текущему). Если да — переходит в ```CHANGE_DIRECTION```. Если нет — остаётся в ```MOVING```.
```CHANGE_DIRECTION```|Состояние изменения направления движения змейки. Устанавливает новое направление на основе валидного ввода пользователя. После этого возвращается в ```MOVING```.
```SHIFT```|Состояние, в котором змейка фактически сдвигается на одну позицию вперёд. Это может быть частью цикла ```MOVING```, но выделено как отдельное действие. После сдвига — возврат в ```MOVING```
```COLLISION_CHECK```|Проверка на столкновение. Проверяются две вещи: 1) столкнулась ли змейка с границами поля или сама с собой; 2) съела ли она яблоко. Результаты проверки определяют дальнейшие переходы.
```GAME OVER```|Решающее условие. Если ```COLLISION_CHECK``` выявил поражение (столкновение с границей или собой), то игра завершается — переход в ```GAME_OVER```. Если нет — проверяется, была ли съедена еда
```APPLE_EATEN```|Проверка, было ли съедено яблоко. Если да — вызывается ```ADD_SCORE``` и ```GROW_SNAKE```. Если нет — игра продолжается в ```MOVING```
```ADD_SCORE```|Увеличение счёта игрока на 1 очко. Вызывается после того, как змейка съела яблоко. После этого переходит в ```GROW_SNAKE```
```GROW_SNAKE```|Увеличение длины змейки на один блок. Происходит после съедения яблока. После этого вызывается ```GENERATE_APPLE```
```GENERATE_APPLE```|Генерация нового яблока на случайной позиции на поле. После этого происходит возврат в ```MOVING``` для продолжения игрового цикла.
```GAME_OVER```|Конечное состояние поражения. Игра останавливается. Выводится сообщение о проигрыше. После этого происходит переход в ```SHUTDOWN```
```SHUTDOWN```|Финальное состояние. Все ресурсы освобождаются, игра полностью завершается.

**Переходы** инициируются:

- пользовательским вводом (`стрелки`, `P`, `Enter`, `Q`);
- игровым таймером;
- условиями победы/поражения.
>Диаграмма КА приведена в разделе [Диаграмма конечного автомата](#диаграмма-конечного-автомата).

### Паттерн MVC
Архитектура десктопного интерфейса строго следует паттерну **MVC**:

- **Model**:
  Класс ```Model```
  Содержат всю бизнес-логику, состояние игры, КА, данные поля.
- **View**:
  Виджеты ```Qt``` (```QMainWindow```, ```StatusWidget```, ```SnakeGame```, ```TetrisGame``` и т.д.).
  Отвечают только за отрисовку и ввод — без логики.
- **Controller**:
  Класс ```Controller``` (тонкий).
  Передаёт сигналы от ```View``` к ```Model``` и обновляет ```View``` по событиям от ```Model```.
>Никакой бизнес-логики в ```View```. Никакого GUI-кода в ```Model```.

## Логика игр

### Snake
- **Поле**: 10×20 блоков.
- **Начальная длина змейки**: 4 блока.
- **Управление**: стрелки (только повороты влево/вправо относительно текущего направления).
- **Яблоко**: появляется случайно; при поедании +1 к длине и +1 очко.
- **Победа**: длина = 200.
- **Поражение**: столкновение с границей или собой.
- **Ускорение**: клавиша действия (например, Space) временно увеличивает скорость.
- **Уровни**: каждые 5 очков → +1 уровень (макс. 10). Каждый уровень ускоряет таймер.

### Tetris
- Полностью перенесён из ```BrickGame v1.0```.
- Поддерживает все механики оригинальной реализации:
  - вращение фигур,
  - ускорение падения,
  - линии, очки, уровни,
  - паузу и выход.
- Работает как в консоли, так и в десктопном интерфейсе.

## Интерфейсы

### Консольный интерфейс

- Расположен в ```src/gui/cli```.
- Использует ncurses для отрисовки.
- Поддерживает обе игры через единый CLI-менеджер.
- Управление: клавиши ```←/→/↓/↑```, ```Space```, ```P```, ```Q```.

### Десктопный интерфейс (Qt)

- Реализован на **Qt 6** (C++20 совместим).
- Единое окно с выбором игры при запуске.
- Боковая панель отображает:
  - текущие очки,
  - уровень,
  - рекорд.
- Поддерживает горячие клавиши, кнопки и полноэкранный режим.

## Сборка и установка

Проект собирается с помощью ```Makefile``` с поддержкой стандартных GNU-целей:

```
make all        # Сборка библиотеки и обоих интерфейсов
make test       # Запуск unit-тестов (GTest)
make install    # Установка в каталог по умолчанию
make uninstall  # Удаление
make clean      # Очистка объектов
make dist       # Создание архива исходного кода
```

### Зависимости:

- ```C++20```-совместимый компилятор
- ```CMake``` (для ```Qt```)
- ```Qt5``` (для десктопного интерфейса)
- ```ncurses``` (для консольного интерфейса)

## Тестирование

- Unit-тесты написаны с использованием ```Google Test```.
- Особое внимание уделено:
  - корректности переходов КА,
  - граничным условиям (победа/поражение),
  - работе с памятью и исключениями.

Запуск тестов:
```
make test
```
## Хранение рекорда
- Максимальное количество очков сохраняется в файле:
```src/brickgame/snake_high_score.txt``` и ```src/brickgame/tetris/high_score.txt```
- Формат: простой .txt файл 
- При запуске игра загружает рекорд; при превышении — обновляет файл.
- Поддерживается для обеих игр, но хранится раздельно.
>Альтернатива: встраиваемая СУБД (например, SQLite) — не реализована, но архитектура позволяет легко добавить.

## Диаграмма конечного автомата
Диаграмма состояний и переходов для игры Snake доступна в файле:
```src/snake_SM.png```
Диаграмма состояний и переходов для игры Tetris доступна в файле:
```src/state_machine.png```

Она включает все состояния (```START```, ```MOVING```, ```PAUSED```, ```GAME_OVER```, ```VICTORY```) и триггеры переходов (ввод, таймер, условия победы/поражения).
